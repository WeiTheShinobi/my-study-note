# Syetem Design

## 單體與微服務

微服務更加複雜，

而且需要額外的補助系統，

例如 log 來追蹤、服務發現、自動化等等，

服務間的網路溝通會略慢一些，

微服務的好處是：

不同服務可以使用不同的技術

更好部署

更好協作

> 單體和微服務的選擇取決於專案的大小與人力，
>
> 大型公司需要微服務．

## 服務間溝通

- 同步

每個服務都同步溝通，

需要應付很多場景，某個環節出錯很麻煩，

服務間緊密的耦合，

使用者要等待非常久的延遲．

- 非同步

服務非同步可以更快，

某些服務出錯時，我們沒辦法取消流程．

- 綜合方案

某些強制任務以同步方法執行ㄝ

除此之外都用非同步執行．

但還是有個問題，

如果服務請求失敗，

我們可能會丟失狀態．

可以加入消息對列．

- Message Queue

消息對列存儲非同步的請求，

保存請求的狀態，

出版者放入對列，

訂閱者從對列取出．

- Message Queue 的好處

提升穩定性，

更好擴展，而且擴展需要耗費的硬體更小，

減少系統的複雜性．因為少了連動性操作．

## 通訊協定

- HTTP

現在都通常的使用HTTPS來避免中間人攻擊

- WebSocket

需要持續溝通使用

比較耗資源

要考慮場景選擇

## Consistent Hashing

> 一致性哈希

### 傳統 mod

在以前，我們算出 hash 並 mod，

來決定我們使用哪個節點，

但這種做法讓我們在增加或刪減服務時，

會很困擾，

因為這會讓映射規則失效，

已經算出的 hash 需要重新安排是很大的花費．

#### 延伸閱讀 布林過濾器

> 透過一個位元向量（0與1）與幾個 hash function，
>
> 一種快速的方式幫我們去重，
>
> 計算出可能存在與確定不存在，
>
> 原理：計算 n 個 Hash 並將向量對應改成 1，如果本來就都是 1，
>
> 則代表可能已經存在，
>
> 會說可能是因為哈希可能碰撞的關係．

### 一致性哈希

有一個哈希環

我們把服務和對象都放在上面

對象順時針查找最近的服務

服務增加與減少只有少數對象需要重新分配

但這也有對象分配不均的問題

可以給服務多個虛擬節點在哈希環上

讓對象對配到虛擬節點

節點帶往映射的服務

## Cache

cache 存在記憶體中，很高效率，但比較貴

適合存放一些常用的資料（減少讀取資料庫次數）

或是困難的運算結果

- 不使用 cache 的情況
  1. 高一致性要求
  2. 大量寫入，讀取超少
  3. 低重複的資料

### 緩存失效策略

#### 以時間

- time to live：時間到失效

#### 以空間

- FIFO：先進先出
- LFU：使用頻率最少先失效
- LRU：如果資料最近被訪問，代表之後也會比較常被訪問．最久沒被訪問先失效
- LFRU：以上兩種綜合，最不常使用且最近也沒被使用會失效．

### 評估指標

- 緩存大小
- 效能：引入緩存得到的效益
- 命中率：你的緩存真的被使用到的機率

## Database

當我們選擇資料庫，

指的是非功能性需求，

因為不論你用哪個資料庫，

都可以滿足你的功能需求，

只是效率問題．

- Cache

**Redis**, **Memcache**...

- 檔案

CDN

- 提供搜尋的文件資料庫

**Solr**,  **Elasticsearch**

可以模糊查詢

- 時間序列資料庫、資料存取倉庫等等...

### 選擇

需要 ACID？ MySQL...

文件資料庫？ MongoDB

加上搜尋？ElasticSearch

> ElasticSearch 是一種特別的文件資料庫

不斷增加資料？很少的種類？

Columnar DB

現實中我們要根據資料需求來決定選擇的資料庫，

大流量系統中，

更複雜的案例往往需要多個不同資料庫的優點來配合

## Rate Limiting

限制流量來阻擋機器人與惡意攻擊，

避免被商業對手頻繁爬蟲

- Leaky Bucket
- Fixed Window
- Sliding Window

   
