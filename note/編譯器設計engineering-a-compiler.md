# 編譯器設計 Engineering a compiler

> WeiTheShinobi 的讀書筆記

## 一、簡介

source code -> 編譯器前端 -> 中間表示(IR) -> 編譯器後端 -> target code

- 編譯器前端：處理 source code
- 編譯器後端：處理 target code
- IR：編譯器使用一些資料結構來表達處理後的 code

輸入 source code 輸出 target code，編譯器不一定要是輸出機器碼

> 直譯器 vs 編譯器
>
> 解釋 code 產生結果, 轉化為 target code

編譯器的基本規則：

- 編譯器必須保持被編譯程序的語意

編譯器不應該隨便更改 source code 想表達的意思

- 編譯器必須以某種可察覺的方式改進輸入程序

輸出的結果要比輸入更好，不然沒有意義

---

三階段編譯器：

source code -> 前端 -> 優化器 -> 後端 -> target code

IR 可以解開前後端的耦合，搭配不同的後端，一份 source code 即可編譯出多種 target code，反之

優化器是一個 IR 到 IR 的轉換

## 二、詞法分析

lexer 在編譯器的第一階段，lexer 讀取 source code 轉換成 token stream

> 暫略

## 三、語法分析

語法分析器用來判斷一個 token stream s 是否屬於一個形式語法(formal grammer) G 定義的語言，即成員資格問題，如果能則說 G 可以推導出 s。

- 為什麼不使用正則表達式？

確實可以寫出大部分的算式，但考慮到`(`和`)`，無法寫出這兩個符號必須一樣的正則表達式，即是`number of (` = `number of )`的情況並非正則語言，這是正則表達式的限制。

### 上下文無關語法

簡稱 CFG，G 是一組規則，可以從 G 推導出的規則稱為 L(G)。

- 產生式：CFG 中的每個規則都是一個產生式
- 非終結符：產生式中使用的變量
- 終結符：出現在語句中的單詞

// p65

// 暫略 lexer, paser 回頭再看

## 四、上下文相關分析

編譯器必須建立龐大的知識庫，了解數值的移動、程式的結構等等，編譯器需要一些方法來考察程式，類型系統、存儲映射、控制流圖等等。

### 概述

假設被編譯的程式使用到`x`

- x 存了什麼類型？
- x 的資料大小？
- 如果 x 是一個過程，需要什麼參數？
- 生命週期：編譯器確保 x 能被合法的使用
- 空間分配

上下文無關文法處理的是語法的範疇，但無法處理將變量名匹配到另一個變量，畢竟都不管上下文了，當然不會知道這些變量是什麼。編譯器必須更深入研究程式的語意（語意分析）

### 類型系統

一個整數類型有限定的範圍，例如`2^31`，結構體內有特定的類型，程式語言中的類型集合以及行為規則總稱為類型系統。

類型系統是為了更精確的規定程式，它建立一個詞彙表來描述有效程式的行為和形式，安全、表達力、執行效率。

編譯器推測每個表達式的類型，並以此消除執行期的錯誤，例如浮點數和整數計算，但也沒辦法消除所有錯誤，因為錯誤程式是一個不可計算的集合。

> 類型推斷：推測每個名字或表達式類型的過程

不同的類型能否進行運算取決於語言的實作

> 隱式轉型：允許運算符號使用不同的類型操作

- 強型別：每個表達式都能分配一個無歧義的類型
- 靜態型別：編譯時就能確定類型
- 動態型別：運行時才能確定類型

> 運算符重載：運算符能通過上下文來決定語意，像是不同的類型對於`+`有不同的結果。

#### 生成更好的程式碼

編譯時期檢查可以生成更高效的程式碼，類型有`value`和`tag`在檢查中用到，如果這個步驟延後到運行時，那就需要更多的記憶體空間和步驟，更大的空間也將使得寄存器放不下而放到記憶體中，更多步驟和更大空間增加了開銷。

### 類型系統的組件

- 基礎型別：數字、字符等等，取決於語言的實作

- 複合或構造類型：指標、結構體、陣列

- 類型等價性：

1. 同名規則：名字一樣
2. 同結構規則：比較類型的內容是否一樣

- 用於推斷的規則：不同的類型在賦值時和計算時的規則。例如`int`和`float`相加、把整數賦值給字串型別等等。

兩種常見的分配型別方法：

1. 形式：`1`是整數、`1.0`是浮點數
2. 上下文推斷

> 編譯器能通過動態檢查實現強型別的靜態型別語言，例如 Java。

- 推斷表達式的類型

最簡單的方法是替每個元素分配一個類型

- 類型推斷

編譯器檢查函數調用時的參數、取得函數簽名

> 類型系統將名字關聯到每個值，即是類型，表示了此類型的一種規則、性質 

### 屬性語法框架 (attribute grammar)

一個上下文無關語法加上一組規則


| Number -> Sign List | List.position <- 0<br>if Sign.negative<br>then Number.value <- -List.value<br>else Number.value <- List.value |
| --------------------- | ------------------ |
| ... | ... |

上表為一個示範，示範中也能注意到，求值是有依賴順序的，先求 `List` 中的值才能知道 `Number`的值，以此我們便能畫出依賴關係圖。

> 環：屬性語法對某些輸入會產生環時，該屬性語法是有環的

- 綜合屬性 Synthesized Attributes：從子節點的屬性值計算出父節點的屬性值（從下往上）
- 繼承屬性 Inherited Attributes：從父節點或兄弟節點的屬性值計算出子節點的屬性值（從上往下）

#### 求值的方法

- 動態方法：每個操作都就緒即可求值，可以建立依賴關係圖後用拓撲排序實現
- 無關方法：從左到右或從右到左重複多趟求值，缺乏對特定樹的改進能力
- 基於規則的方法： 靜態分析來構造出求值次序

### 環

依賴關係圖出現環時，求值會失敗。

- 避免：限制語法只使用綜合屬性和常量，避免繼承屬性。

  > 綜合屬性由下往上求值，繼承屬性由上而下，兩者同時使用便有機會形成環

- 求值：求值程式可以走訪環，給予默認值

 
