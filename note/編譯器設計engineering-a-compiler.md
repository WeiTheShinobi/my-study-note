# 編譯器設計 Engineering a compiler

> WeiTheShinobi 的讀書筆記

## 一、簡介

source code -> 編譯器前端 -> 中間表示(IR) -> 編譯器後端 -> target code

- 編譯器前端：處理 source code
- 編譯器後端：處理 target code
- IR：編譯器使用一些資料結構來表達處理後的 code

輸入 source code 輸出 target code，編譯器不一定要是輸出機器碼

> 直譯器 vs 編譯器
>
> 解釋 code 產生結果, 轉化為 target code

編譯器的基本規則：

- 編譯器必須保持被編譯程序的語意

編譯器不應該隨便更改 source code 想表達的意思

- 編譯器必須以某種可察覺的方式改進輸入程序

輸出的結果要比輸入更好，不然沒有意義

---

三階段編譯器：

source code -> 前端 -> 優化器 -> 後端 -> target code

IR 可以解開前後端的耦合，搭配不同的後端，一份 source code 即可編譯出多種 target code，反之

優化器是一個 IR 到 IR 的轉換

## 二、詞法分析

lexer 在編譯器的第一階段，lexer 讀取 source code 轉換成 token stream

> 暫略

## 三、語法分析

語法分析器用來判斷一個 token stream s 是否屬於一個形式語法(formal grammer) G 定義的語言，即成員資格問題，如果能則說 G 可以推導出 s。

- 為什麼不使用正則表達式？

確實可以寫出大部分的算式，但考慮到`(`和`)`，無法寫出這兩個符號必須一樣的正則表達式，即是`number of (` = `number of )`的情況並非正則語言，這是正則表達式的限制。

### 上下文無關語法

簡稱 CFG，G 是一組規則，可以從 G 推導出的規則稱為 L(G)。

- 產生式：CFG 中的每個規則都是一個產生式
- 非終結符：產生式中使用的變量
- 終結符：出現在語句中的單詞

// p65

// 暫略 lexer, paser 回頭再看

## 四、上下文相關分析

編譯器必須建立龐大的知識庫，了解數值的移動、程式的結構等等，編譯器需要一些方法來考察程式，類型系統、存儲映射、控制流圖等等。

### 概述

假設被編譯的程式使用到`x`

- x 存了什麼類型？
- x 的資料大小？
- 如果 x 是一個過程，需要什麼參數？
- 生命週期：編譯器確保 x 能被合法的使用
- 空間分配

上下文無關文法處理的是語法的範疇，但無法處理將變量名匹配到另一個變量，畢竟都不管上下文了，當然不會知道這些變量是什麼。編譯器必須更深入研究程式的語意（語意分析）

### 類型系統

一個整數類型有限定的範圍，例如`2^31`，結構體內有特定的類型，程式語言中的類型集合以及行為規則總稱為類型系統。

類型系統是為了更精確的規定程式，它建立一個詞彙表來描述有效程式的行為和形式，安全、表達力、執行效率。

編譯器推測每個表達式的類型，並以此消除執行期的錯誤，例如浮點數和整數計算，但也沒辦法消除所有錯誤，因為錯誤程式是一個不可計算的集合。

> 類型推斷：推測每個名字或表達式類型的過程

不同的類型能否進行運算取決於語言的實作

> 隱式轉型：允許運算符號使用不同的類型操作

- 強型別：每個表達式都能分配一個無歧義的類型
- 靜態型別：編譯時就能確定類型
- 動態型別：運行時才能確定類型

> 運算符重載：運算符能通過上下文來決定語意，像是不同的類型對於`+`有不同的結果。

#### 生成更好的程式碼

編譯時期檢查可以生成更高效的程式碼，類型有`value`和`tag`在檢查中用到，如果這個步驟延後到運行時，那就需要更多的記憶體空間和步驟，更大的空間也將使得寄存器放不下而放到記憶體中，更多步驟和更大空間增加了開銷。

### 類型系統的組件

