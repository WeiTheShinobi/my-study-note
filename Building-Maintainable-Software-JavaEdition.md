# 《*Building Maintainable Software, Java Edition 打造可維護軟體：編寫可維護程式碼的10項法則 （Java版）*》

在圖書館看到這本書，也才一百多頁而已，看到出版商歐萊禮就翻了一下覺得不錯，就借回家來讀，第一次嘗試寫學習筆記，也是嘗試使用更好的學習方法，希望自己未來更強。

> **筆記作者：葉高緯 Wei the Shinobi**

# 1. 簡短的程式碼

> 傻瓜也可寫出電腦能懂得程式碼，但優秀的工程師才能寫出人類能夠理解的程式碼 。	— Martin Fowler
>

- **程式碼單元的長度應在15行內。**

## 1.1 好處

- 容易測試
- 容易分析
- 容易複用

## 1.2 重構技巧

1. 提取方法：將一段很長的程式碼，提取出一部份拆分成新的方法。不僅好讀，還可實現程式碼複用。

- 那如果遇到需要傳送很多區域變數的情況呢？拆分出來的新方法要傳一長串參數肯定很麻煩，這時我們需要另尋他法。

2. 以物件方法取代方法：如果你要傳送一長串的變數，可以把某些要傳遞的區域變數，轉變成類別的私有欄位。就是提升作用域的意思。

```java
class Something {
   void doSomething(int x,String y,int a,int b, int c, int d){
        // ...
    }
}
```

改寫成

```java
class Something {
    private int x;
    private String y;
    
    Something(int x,String y) {
        this.x = x;
        this.y = y;
    }
    
    void doSomething(int a,int b, int c, int d){
        // ...
    }
}
```

## 1.3 討論

1. 效能
   - 實際上效能不會有太大的差別，而且兩害取其輕。
2. 拆分程式碼難以閱讀
   - 其實不會。

#  2. 簡單的程式碼

> 每個問題都是由一些小問題組成的。	— Martin Fowler
>

- **每個程式碼單元不超過4個邏輯分支點。**
- **拆分，避免複雜的糾結。**
- **分支越少，測試及修改能越簡單。**

越多的分支，就有越高的**循環複雜度**，你需要測試的路徑分支就越多。

## 2.1 switch case

- 一長串的switch看起來無害，可讀性也很強，但是想要測試方法需要寫很多個的測試案例。

  1. 替換成map，從map取值時再做出判斷。
  2. 替換成多型。

## 2.2 處理嵌套語句

- 以衛述句取代嵌套條件式
  - 識別不同狀況插入return，來替代嵌套的條件語句。
  - 還可以再使用**提取方法**的技巧來拆分方法。

## 2.3 討論

1. 高複雜度無可避免？

   - 複雜的知識領域未必需要複雜的實作，你還是可以建構簡單的技術方案，而這完全可以辦到。

2. 拆分方法不會降低複雜度

   > 將1個循環複雜度為15的方法拆成3個循環複雜度為5的方法不會降低整體的複雜度，這根本沒用。

   - 的確，但會更容易測試和理解，新撰寫的單元測試也能更簡單。

# 3. 不重複的程式碼

> 排名第一的程式碼壞味道就是程式碼重複。	— Kent Beck 與 Martin Fowler，《*Bad Smells in Code*》

- **禁止程式碼重複。**

## 3.1 定義

- 長度至少6行的一段相同程式碼，不包括空白和註解。

> 複製就像技術債，將來要修改會很痛苦。

# 4. 參數簡單的程式碼

> 四處分散的相關資料應該被封裝成一個物件。	— Martin Fowler

- 限制程式碼單元的參數**不超過4個**。
- **將多個參數提取到class**來達成。
- 較少的參數較容易理解與重複使用。

## 4.1 解決方法

二維或三維空間的參數，長長的一排在方法上，看了就不想讀了。

- 我們可以**引進參數物件**：
  - 寫一個內部類來攜帶參數，例如一個方法要傳正方體的xyz，就可以寫一個內部類正方體class。

- **以物件方法取代方法**：
  - 見**1.2 重構技巧**。

# 5. 不同模組之間的關注點分離

> 在既複雜又緊密耦合的系統中，意外無可避免。	— Charles Perrow 的意外理論（Normal Accidents）

- **避免形成大型模組，達成模組之間的鬆散耦合。**
- **不同職責不同模組，隱藏介面內部實作細節。**

> 這裡的模組概念對應到物件導向語言（如Java）的類別。

## 5.1 動機

你是否有這樣的經驗，一個UserService的class，本來只有幾個服務，後來越加越多，只要跟user有關連的都丟進來，變的巨大難以維護…

- 鬆散耦合的小模組容易維護。
- 讓經驗不足的開發人員不會手足無措。

## 5.2 解決方法

1. 根據不同的關注點拆分
   - 一個UserService可能有郵件相關、提醒或是封鎖，根據不同的功能拆分。
2. 將特定實作隱藏在介面
   - 舉例來說，一個相機有普通功能跟高階功能，你可以實作Camera，然後再實作HighLevelCamera繼承Camera。
   - 僅使用Camera的話，不需要知道HighLevelCamera的實作方法。

# 6. 以鬆散耦合的方式架構元件

> 有兩種方式建構軟體設計：一種是簡單到明顯沒有缺陷，另一種是複雜到沒有明顯缺陷。	— C.A.R. Hoare

- **頂層元件之間應該保持鬆散耦合。**
- **盡量減少目前模組需要暴露給（被呼叫）其他元件之模組的程式碼數量。**
- 此方針可提升**可維護性，因為獨立的元件有利於獨立的維護。**

> - **元件 = 模組群**

## 6.1 可維護性的調用

- 正面：
  - **內部調用是健康的**。元件裡的模組群內部調用。
  - 傳出調用也是健康的。

- 負面：
  - 傳入調用。為其他元件提供功能性應該限制。修改傳入調用的程式碼可能會影響其他程式。
  - 透傳程式碼。透過程式碼接收傳入，再傳出給其他元件，風險不小。

## 6.2 討論

一開始的系統很讚，但隨著時間可能有人違反原則，單向依賴變得混亂模糊。

低度元件依賴讓分工更容易，因為緊密依賴要看其他團隊的臉色。

低度元件依賴讓測試也變得容易，要弄一堆mock實在太麻煩了。

透過**設計模式**可以幫你實現。

- 反對意見：

  - 因為相互糾纏無法修正：分析傳遞調用將邊界劃分清楚。
  
- 例如有大量傳入調用的模組可能表示它們承擔多重職責，可以劃分與拆解。
  
- 我知道這很重要，但我沒時間：你可以衡量維護成本，重點在於權衡。
  
- 透傳調用是需求：
  
  某些架構被設計出中間層，一個服務層收集請求然後打包給其他分層。存在不是問題，但應該分區傳入請求與傳出請求。
  
    - 不應該處理請求本身
    - 不應該知道哪裡及如何處理請求

# 7. 保持架構元件平衡

> 建構封裝邊界是設計軟體架構的重要技巧。 — George H. Fairbanks，《*Just Enough Archiecture*》

- 讓頂層元件的數量和尺寸維持平衡。
- 良好的平衡能讓查詢與分析更容易。
- 能夠更好分工。

# 8. 保持小規模的程式碼基礎

> 程式複雜度持續增加，直到超出維護人員的負荷。 — 電腦編程的第七條法則

- 盡可能保持**小規模的程式碼基礎**
- **小產品、小專案與小團隊是成功的要因**

統計結果顯示，大型專案品質較差，**缺陷密度**較高。

# 9. 自動化測試

> 要想保持程式碼乾淨無慮，先讓測試進度條維持綠色。	— JUnit格言

- 使用**測試框架**。
- 自動化測試讓開發過程**可以預測**並**降低風險**。

## 9.1 動機

- 自動化測試可以反覆進行
- 讓開發更有效率：盡量**在開發流程早期開始測試**，降低修正問題的成本。
- 讓程式碼的行為可預測：避免出現打地鼠的問題。

## 9.2 原則

1. 一般或特殊情況都要測試：
   - 快樂流程測試正常的情況。
   - 不快樂流程測試不正常的情況或確定在測試中拋出特定例外。

2. 像維護非測試程式碼一樣維護測試程式碼：
   - 對系統程式碼進行修改，測試程式碼也會被影響。

3. 獨立的測試：
   - 每個測試都應該只測試一個功能。

4. 覆蓋率在80%以上，幾乎跟產品程式碼差不多。

# 10. 撰寫乾淨的程式碼

> 專業開發者有責任撰寫簡潔的程式碼。 — Robert C. Martin

- **簡潔的程式碼**。
- **童軍守則**：離開營地時，要讓它比原先更乾淨。

## 規則

1. 不要留下單元層級的程式碼壞味道
   
   - 本書前四章的技巧，可以些許違反，但在程式碼**提交到版本控制之前**要修改好。
   
2. 不要撰寫不好的註解
   
   - 好的程式碼和命名足以說明這段在做什麼，不要有教條式的註解。
   
3. 不要再註解中撰寫程式碼
   
   - 對於新的開發人員是種干擾，版本控制會記錄程式碼的。
   
4. 別留下無用的程式碼

   - 無法達到的程式碼、沒被使用的私有方法等等。

5. 不要使用冗長的名稱

6. 不要使用魔法常數

   - 魔法常數是指在程式碼中沒有明確意義的值，例如下方例子的65，應該明確定義。

     ```java
     if (age > 65) {
         // ...
     }
     ```

     ```java
     private static final int OLD_MAN_AGE = 65;
     if (age > OLD_MAN_AGE) {
         // ...
     }
     ```

     

7. 不要留下未正確處理的例外

   - 總是捕捉例外，不要空的catch區塊。
   - 捕捉特定例外，不要捕捉最抽象的。
   - 將例外轉譯成通用訊息，否則使用者會困惑。

 

