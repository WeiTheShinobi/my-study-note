# 《*Building Maintainable Software, Java Edition 打造可維護軟體：編寫可維護程式碼的10項法則 （Java版）*》

在圖書館看到這本書，也才一百多頁而已，看到出版商歐萊禮就翻了一下覺得不錯，就借回家來讀，第一次嘗試寫學習筆記，也是嘗試使用更好的學習方法，希望自己未來更強。

> **筆記作者：葉高緯 Wei the Shinobi**

# 1. 簡短的程式碼

> 傻瓜也可寫出電腦能懂得程式碼，但優秀的工程師才能寫出人類能夠理解的程式碼 。	— Martin Fowler
>

- **程式碼單元的長度應在15行內。**

## 1.1 好處

- 容易測試
- 容易分析
- 容易複用

## 1.2 重構技巧

1. 提取方法：將一段很長的程式碼，提取出一部份拆分成新的方法。不僅好讀，還可實現程式碼複用。

- 那如果遇到需要傳送很多區域變數的情況呢？拆分出來的新方法要傳一長串參數肯定很麻煩，這時我們需要另尋他法。

2. 以物件方法取代方法：如果你要傳送一長串的變數，可以把某些要傳遞的區域變數，轉變成類別的私有欄位。就是提升作用域的意思。

```java
class Something {
   void doSomething(int x,String y,int a,int b, int c, int d){
        // ...
    }
}
```

改寫成

```java
class Something {
    private int x;
    private String y;
    
    Something(int x,String y) {
        this.x = x;
        this.y = y;
    }
    
    void doSomething(int a,int b, int c, int d){
        // ...
    }
}
```

## 1.3 討論

1. 效能
   - 實際上效能不會有太大的差別，而且兩害取其輕。
2. 拆分程式碼難以閱讀
   - 其實不會。

#  2. 簡單的程式碼

> 每個問題都是由一些小問題組成的。	— Martin Fowler
>

- **每個程式碼單元不超過4個邏輯分支點。**
- **拆分，避免複雜的糾結。**
- **分支越少，測試及修改能越簡單。**

越多的分支，就有越高的**循環複雜度**，你需要測試的路徑分支就越多。

## 2.1 switch case

- 一長串的switch看起來無害，可讀性也很強，但是想要測試方法需要寫很多個的測試案例。

  1. 替換成map，從map取值時再做出判斷。
  2. 替換成多型。

## 2.2 處理嵌套語句

- 以衛述句取代嵌套條件式
  - 識別不同狀況插入return，來替代嵌套的條件語句。
  - 還可以再使用**提取方法**的技巧來拆分方法。

## 2.3 討論

1. 高複雜度無可避免？

   - 複雜的知識領域未必需要複雜的實作，你還是可以建構簡單的技術方案，而這完全可以辦到。

2. 拆分方法不會降低複雜度

   > 將1個循環複雜度為15的方法拆成3個循環複雜度為5的方法不會降低整體的複雜度，這根本沒用。

   - 的確，但會更容易測試和理解，新撰寫的單元測試也能更簡單。

# 3. 不重複的程式碼

> 排名第一的程式碼壞味道就是程式碼重複。	— Kent Beck 與 Martin Fowler，《*Bad Smells in Code*》

- **禁止程式碼重複。**

## 3.1 定義

- 長度至少6行的一段相同程式碼，不包括空白和註解。

> 複製就像技術債，將來要修改會很痛苦。

# 4. 參數簡單的程式碼

> 四處分散的相關資料應該被封裝成一個物件。	— Martin Fowler

- 限制程式碼單元的參數**不超過4個**。
- **將多個參數提取到class**來達成。
- 較少的參數較容易理解與重複使用。

## 4.1 解決方法

二維或三維空間的參數，長長的一排在方法上，看了就不想讀了。

- 我們可以**引進參數物件**：
  - 寫一個內部類來攜帶參數，例如一個方法要傳正方體的xyz，就可以寫一個內部類正方體class。

- **以物件方法取代方法**：
  - 見**1.2 重構技巧**。

# 5. 不同模組之間的關注點分離

> 在既複雜又緊密耦合的系統中，意外無可避免。	— Charles Perrow 的意外理論（Normal Accidents）

- **避免形成大型模組，達成模組之間的鬆散耦合。**
- **不同職責不同模組，隱藏介面內部實作細節。**

> 這裡的模組概念對應到物件導向語言（如Java）的類別。

## 5.1 動機

你是否有這樣的經驗，一個UserService的class，本來只有幾個服務，後來越加越多，只要跟user有關連的都丟進來，變的巨大難以維護…

- 鬆散耦合的小模組容易維護。
- 讓經驗不足的開發人員不會手足無措。

## 5.2 解決方法

1. 根據不同的關注點拆分
   - 一個UserService可能有郵件相關、提醒或是封鎖，根據不同的功能拆分。
2. 將特定實作隱藏在介面
   - 舉例來說，一個相機有普通功能跟高階功能，你可以實作Camera，然後再實作HighLevelCamera繼承Camera。
   - 僅使用Camera的話，不需要知道HighLevelCamera的實作方法。

# 6. 以鬆散耦合的方式架構元件

> 有兩種方式建構軟體設計：一種是簡單到明顯沒有缺陷，另一種是複雜到沒有明顯缺陷。	— C.A.R. Hoare

- **頂層元件之間應該保持鬆散耦合。**
- **盡量減少目前模組需要暴露給（被呼叫）其他元件之模組的程式碼數量。**
- 此方針可提升**可維護性，因為獨立的元件有利於獨立的維護。**







# 9. 自動化測試

> 要想保持程式碼乾淨無慮，先讓測試進度條維持綠色。	— JUnit格言

- 使用**測試框架**。
- 自動化測試讓開發過程**可以預測**並**降低風險**。

## 9.1 動機

- 自動化測試可以反覆進行
- 讓開發更有效率：盡量**在開發流程早期開始測試**，降低修正問題的成本。
- 讓程式碼的行為可預測：避免出現打地鼠的問題。

## 9.2 原則

1. 一般或特殊情況都要測試：
   - 快樂流程測試正常的情況。
   - 不快樂流程測試不正常的情況或確定在測試中拋出特定例外。

2. 像維護非測試程式碼一樣維護測試程式碼：
   - 對系統程式碼進行修改，測試程式碼也會被影響。

3. 獨立的測試：
   - 每個測試都應該只測試一個功能。

4. 覆蓋率在80%以上，幾乎跟產品程式碼差不多。





# 待更新...

