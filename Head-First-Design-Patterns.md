# Head First Design Patterns

> 書名：《*Head First Design Patterns*》
>
> 筆記作者：葉高緯 Wei the Shinobi

之前看了《*Head First Java*》，我覺得Head First系列都很讚。

# 介紹設計模式

設計模式讓我們與其他人討論時更方便，

現在有一個鴨子父類，

有很多不同的鴨子子類會繼承，

但是不同的鴨子有不同的行為，

像是呱呱叫和飛翔，

個別修改不同的行為對於日後維護困難。

## 把變動部分封裝起來

我們可以把呱呱叫和飛翔從鴨子中取出，

建立一個新的類別。

> 封裝呱呱叫和飛翔的行為。

## 針對介面寫程式，不是針對實踐寫程式

在鴨子class中，

選擇行為的介面。

```java
FlyBehavior fly = new FlyNoWay;
```

## 多用合成，少用繼承

我們把行為的介面和鴨子組合起來，

而不是把繼承行為，

組合更加靈活，

還可以動態指定不同的行為。

> 「有一個」比「是一個」更好。

## 策略模式

定義了演算法家族，個別封裝，讓它們可以替換，演算法的變動不會影響使用演算法的程式。

舉例：

一個角色有一個武器行為，

做出一個武器行為介面，

可以實作出不同武器的武器行為，

還可以使用角色的`setWeapon`方法來替換武器。

# 觀察者模式

定義了物件之間的一對多關係，當一個物件改變狀態，其他相依者都會收到通知並更新。

就像是報社和訂閱者，

訂閱可以收到報紙，

也可以取消訂閱就不再收到報紙。

設計主題介面與觀察者介面。

## 設計時，盡量讓需要互動的物件之間關係鬆綁

當兩個物件被鬆綁，

依然可以互動，

但是不太清楚彼此的細節。

## 通知變更

有時候資訊頻繁改動，

可以設定`setChange`方法，

自訂改動的幅度才通知觀察者。

# 裝飾者模式

動態地將責任加諸於物件上。若要擴充功能，裝飾者提供比繼承更有彈性的選擇。

讓裝飾者與被裝飾者能使用多型，

繼承同一個類，

再建構式中實例化父類。

範例：

```java
Drink drink = new coffee();
drink = new Mocha(drink);
drink = new Whip(drink);
```

這看起來有沒有像什麼？

就是Java的IO流

`FileInputStream`是被裝飾者

像是`BufferedInputStream`之類的裝飾者都繼承了`FilterInputStream`

可以裝飾`FileInputStream`

而且他們全都繼承自同一個抽象類

了解了這些你甚至可以繼承`FilterInputStream`來撰寫自己的裝飾者

## 缺點

- 大量的小類別不容易被理解設計方式

如同第一次接觸IO庫，

無法輕易地知道用法。

- 裝飾者實體化元件時，將增加程式的複雜度

要一直包包包

# 工廠模式

