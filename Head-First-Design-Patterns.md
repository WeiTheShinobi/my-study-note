# Head First Design Patterns

> 書名：《*Head First Design Patterns*》
>
> 筆記作者：葉高緯 Wei the Shinobi

之前看了《*Head First Java*》，我覺得Head First系列都很讚。

# 介紹設計模式

設計模式讓我們與其他人討論時更方便，

現在有一個鴨子父類，

有很多不同的鴨子子類會繼承，

但是不同的鴨子有不同的行為，

像是呱呱叫和飛翔，

個別修改不同的行為對於日後維護困難。

## 把變動部分封裝起來

我們可以把呱呱叫和飛翔從鴨子中取出，

建立一個新的類別。

> 封裝呱呱叫和飛翔的行為。

## 針對介面寫程式，不是針對實踐寫程式

在鴨子class中，

選擇行為的介面。

```java
FlyBehavior fly = new FlyNoWay;
```

從介面呼叫方法易於維護與擴充。

## 多用合成，少用繼承

我們把行為的介面和鴨子組合起來，

而不是把繼承行為，

組合更加靈活，

還可以動態指定不同的行為。

> 「有一個」比「是一個」更好。

## 策略模式

定義了演算法家族，個別封裝，讓它們可以替換，演算法的變動不會影響使用演算法的程式。

舉例：

一個角色有一個武器行為，

做出一個武器行為介面，

可以實作出不同武器的武器行為，

還可以使用角色的`setWeapon`方法來替換武器。

# 觀察者模式

定義了物件之間的一對多關係，當一個物件改變狀態，其他相依者都會收到通知並更新。

就像是報社和訂閱者，

訂閱可以收到報紙，

也可以取消訂閱就不再收到報紙。

設計主題介面與觀察者介面。

## 設計時，盡量讓需要互動的物件之間關係鬆綁

當兩個物件被鬆綁，

依然可以互動，

但是不太清楚彼此的細節。

## 通知變更

有時候資訊頻繁改動，

可以設定`setChange`方法，

自訂改動的幅度才通知觀察者。

# 裝飾者模式

動態地將責任加諸於物件上。若要擴充功能，裝飾者提供比繼承更有彈性的選擇。

讓裝飾者與被裝飾者能使用多型，

繼承同一個類，

再建構式中實例化父類。

範例：

```java
Drink drink = new coffee();
drink = new Mocha(drink);
drink = new Whip(drink);
```

這看起來有沒有像什麼？

就是Java的IO流

`FileInputStream`是被裝飾者

像是`BufferedInputStream`之類的裝飾者都繼承了`FilterInputStream`

可以裝飾`FileInputStream`

而且他們全都繼承自同一個抽象類

了解了這些你甚至可以繼承`FilterInputStream`來撰寫自己的裝飾者

## 缺點

- 大量的小類別不容易被理解設計方式

如同第一次接觸IO庫，

無法輕易地知道用法。

- 裝飾者實體化元件時，將增加程式的複雜度

要一直包包包

# 工廠模式

工廠模式將建立物件的程式碼集中在一個物件或行為中，

在進行物件實體化時只會用到介面，

不再依賴實踐類，

讓程式更有彈性方便修改。

```java
Duck dukc;

if(a) {
    duck = new RubberDuck();
} else if (b) {
    duck = new NormalDuck();
} else if (c) {
    // ...
}
```

我們針對介面寫程式，

介面透過多型來實例化不同的實現類，

但如果已有大量的實現類，

要加入新的實現類就要**修改舊的程式碼**，

而這正是我們不樂見的，

所以**我們找出會改變的地方，然後將這部分抽離出來，**

所以工廠誕生了。

## 簡單工廠

單純的把剛剛那段示範程式碼抽取出來，

寫進一個新的類中，

在需要用到工廠的時候呼叫。

簡單工廠其實不是設計模式，反而比較像是一種編程習慣。

## 工廠模式

定義一個建立物件的介面，但由子類別**決定**要實體化的類別為何。工廠方法讓類別把實體化的動作，交由子類別進行。

所謂的「決定」，並不是指模式允許子類別在執行期作決定，

而是指：在撰寫創建者類別（工廠）時，不需要知道實際建立的產品為何，

選擇哪個子類別（工廠），自然就決定了實際建立的產品為何。

## 依賴反轉守則

**依賴抽象類別，不要依賴實現類別。**

舉例來說：

披薩店依賴於一堆不同口味的特色披薩，

不如依賴於披薩抽象，

讓特色披薩實作披薩抽象。

那反轉在哪？

本來披薩店直接依賴一堆特色披薩（低階元件），

現在披薩店依賴披薩抽象，

而特色披薩依賴披薩抽象，

相依被顛倒了。

### 指導方針

- 變數不可以持有實現類的參考

  ​	這就是為什麼我們不使用`new`，改用工廠迴避。

- 不要讓類別繼承自實現類

- 不要讓子類`override`父類的方法

  ​	如果這樣，說明這不適合繼承。

當然不可能完全遵守這些守則，

否則你什麼都寫不出來。

## 抽象工廠

工廠的工廠，抽象工廠定義了我們該怎麼蓋工廠。

抽象工廠提供介面，

以實踐各式各樣的工廠，

工廠方法就潛伏在抽象工廠中。

### 比較抽象工廠與工廠方法

- 工廠提供介面建立出產品`createPizza()`
- 抽象工廠提供介面建立一個產品家族，像是披薩的原物料，原物料又會有工廠。

# 單例模式

確保一個類別只有一個實體，並給它一個存取的global point。

有些物件只需要一個，如果有多個實體，就會出事。

## 基本

私有建構式

```java
public MyClass {
    private MyClass(){}
    
    public static MyClass getInstance(){
        return new MyClass();
    }
}
```

## 多執行緒的問題

**Lazy Instantiaze**

```java
private static MyClass myClass;
public static MyClass getInstance(){
	if (myClass == null) {
        myClass = new MyClass();
    }
    return myClass;
}
```

多執行緒處理最基本的單例模式有機會出問題，

例如`getInstance()`產生多個實體，

我們可以在方法加上`synchronized`關鍵字。

雖然這個方法簡單又有效，

但是加上這個關鍵字會拖垮效能，

因為我們只需要在第一次產生實體時排隊就好，

不需要每一次。

### 解決辦法

- 使用`synchronized`關鍵字不管效能

如果效能對你來說沒那麼重的話。

- 不用拖延實體化的作法

```java
// 直接建立一個
private static MyClass myClass = new MyClass();

public static MyClass getInstance(){
    return myClass;
}
```

- 雙重鎖

原理：先檢查是否實體化，如果還沒，才會同步化，這樣就只會進行一次同步化。

```java
// 加上volatile關鍵字確保可見性
private volatile static MyClass myClass;

public static MyClass getInstance(){
    // 檢查是否實體化，如果不存在才會進入同步化區塊。
	if (myClass == null) {
        synchronized (Singleton.class) {
            if (myClass == null) {
                myClass = new MyClass();
            }
        }
    }
    
    return myClass;
}
```

# 命令模式

將請求封裝成物件。

像是一間餐廳，

你把菜單給服務生，

服務生把菜單給廚師，

而服務生不會知道菜單是什麼。

或者說是遙控器和家電，

你按下遙控器，

遙控器調用封裝好的命令介面給電器，

電器執行它該做的，

所以我們要寫一個命令介面，

還需要調用者，

然後把命令介面傳進調用者中，

調用者負責執行。

# 轉接器模式與表象模式

## 轉接器模式

將一個類別的介面，轉換成另一個介面。

轉接器不難理解，

插頭和插座的形狀不一樣，

就需要轉接器，

讓我們不用改寫插頭或插座。

### 物件轉接

```java
c.lass TurkeyAdapter implements Duck {
    // ...
    public void quack() {
        turkey.gobble(); // 呼叫火雞的方法
    }
}
```

這段程式碼中，

我們把火雞透過轉接器，

轉換成鴨子。

### 類別轉接

不使用合成改變被轉接者，

而是**多重繼承**被轉接者和目標類別，

設計出類別轉接器。

不過關鍵就在**多重繼承**，

Java是無法多重繼承的，

但也許有天寫C++的時候可以用到。

---

不論哪種方法，

客戶都會認為他在跟鴨子溝通，

但其實是轉接過的火雞。

## Facade 表象模式

提供一個統一的介面，存取次系統中的一群介面。

表象用於簡化介面，

本來你要調用一堆次系統的介面，

但表象把它們集中起來管理，

就可以讓你只要調用表象，

其實非常好懂。

### 極少化守則

**只和你的密友談話。**

這個守則希望我們不要讓太多類別綑綁在一起，

要減少物件之間的互動。

**把極少化守則與表象模式配合，**

透過表象模式讓你的系統不用依賴一堆次系統，

實現極少化守則。

# 樣板方法模式

將一個演算法的骨架定義在一個方法中，而演算法本身會用到的一些方法定義在子類別中。

```java
abstract class AbstractClass {
    final void templateMethod() {
        opera1();
        opera2();
        opera3();
    }
    
    abstract void opera1();
    
    abstract void opera2();
    
    void opera3() {
        // implementation here
    }
    
    void hook() {}
    // 鉤子方法，子類別可以視情況決定要不要override鉤子
}
```

這段程式碼簡單的示範了模板方法模式。

## 好萊塢守則

高階元件：別呼叫我們，我們會呼叫你。

好萊塢守則是一個防止**依賴腐敗**的方法。

演員投出履歷給好萊塢的製作人，

但製作人要看上百封履歷，

如果每個人都要回覆就沒時間了，

所以讓只讓製作人呼叫演員。

只讓高階元件呼叫低階元件，

低階不能直接呼叫高階。

# 反覆器與合成模式

